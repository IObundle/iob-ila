// This file is included by the source generated by ilaGenerateSource.py
// It contains the static code that depends on the defines generated

#include "iob-ila.h"
#include "printf.h"

static inline char intToHex(int val){
    if(val <= 9)
        return '0' + val;
    else
        return 'A' + (val - 10);
}

static inline char* OutputHex(char* buffer,int value){
	int lw = intToHex(value % 16);
	int hw = intToHex(value / 16);

	(*buffer++) = hw;
	(*buffer++) = lw;

	return buffer;	
}

int ila_output_data_size(int number_samples, int ila_dword_size){
    int size_per_line = ila_dword_size * 8 + 1; // +1 for '\n'
    int size = size_per_line * number_samples + 1; // +1 for '\0'

    return size;
}

int ila_output_data(char* buffer,int start, int end, int buffer_size, int ila_dword_size){
    union{char i8[4];int i32;} data;

    buffer[0] = '\0'; // For the cases where end - start == 0

    for(int i = start; ; i=(i+1)%buffer_size){
        for(int ii = ila_dword_size - 1; ii >= 0; ii--){
            data.i32 = ila_get_large_value(i,ii);
            buffer = OutputHex(buffer,data.i8[3]);
            buffer = OutputHex(buffer,data.i8[2]);
            buffer = OutputHex(buffer,data.i8[1]);
            buffer = OutputHex(buffer,data.i8[0]);
        }
        
        (*buffer++) = '\n';

        if(i == end) break;
    }
    *buffer = '\0';

    int res = end<start ? end+buffer_size-start : end - start;
    return res;
}

void ila_output_everything(int ila_dword_size, int buffer_size){
    char buffer[1024]; // TODO: Make sure buffer size is big enough (can calculate at generate time)

    for(int i = 1; i <= buffer_size;){
        i += ila_output_data(buffer,i - 1,i, buffer_size, ila_dword_size); 
        printf("%s",buffer);
    }
}
