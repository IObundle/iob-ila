// This file is included by the source generated by ilaGenerateSource.py
// It contains the static code that depends on the defines generated

#include "iob-ila.h"
#include "printf.h"

static inline char intToHex(int val){
    if(val <= 9)
        return '0' + val;
    else
        return 'A' + (val - 10);
}

static inline char* OutputHex(char* buffer,int value){
	int lw = intToHex(value % 16);
	int hw = intToHex(value / 16);

	(*buffer++) = hw;
	(*buffer++) = lw;

	return buffer;	
}

int ila_output_data_size(int number_samples, int ila_dword_size){
    int size_per_line = ila_dword_size * 8 + 1; // +1 for '\n'
    int size = size_per_line * number_samples + 1; // +1 for '\0'

    return size;
}

//TODO: Add buffer size and make function only output if enough size remaining
int ila_output_data(char* buffer,int start, int end, int ila_dword_size){
    union{char i8[4];int i32;} data;

    buffer[0] = '\0'; // For the cases where end - start == 0

    for(int i = start; i < end; i++){
        for(int ii = ila_dword_size - 1; ii >= 0; ii--){
            data.i32 = ila_get_large_value(i,ii);
            buffer = OutputHex(buffer,data.i8[3]);
            buffer = OutputHex(buffer,data.i8[2]);
            buffer = OutputHex(buffer,data.i8[1]);
            buffer = OutputHex(buffer,data.i8[0]);
        }
        
        (*buffer++) = '\n';
    }
    *buffer = '\0';

    int res = end - start;
    return res;
}

void ila_output_everything(int ila_dword_size){
    char buffer[1024]; // TODO: Make sure buffer size is big enough (can calculate at generate time)
    int number_samples = ila_number_samples(); // Lock number of samples

    for(int i = 1; i <= number_samples;){
        i += ila_output_data(buffer,i - 1,i, ila_dword_size); 
        printf("%s",buffer);
    }
}
